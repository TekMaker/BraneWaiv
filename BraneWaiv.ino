/*
  ****** COPYRIGHT WARNING ******
  This code is free for personal use, if you want to modify the code please credit me it.
  I assert my copyright Ralph Beardmore, AKA TekMaker (UK). 19/10/2025
  https://www.youtube.com/@tekmakerUK
*/


/*
   -- BraneWaiv --
   
   To compile this code using RemoteXY library 4.1.4 or later version 
   download by link http://remotexy.com/en/library/
   To connect using RemoteXY mobile app by link http://remotexy.com/en/download/                   
     - for ANDROID 4.16.02 or later version;
     - for iOS 1.13.1 or later version;
    
   To interact with the GUI, please refer to the manual: 
   https://remotexy.com/ru/help/code/interaction/

   This source code was automatically generated by the RemoteXY editor and 
   is an example for the RemoteXY library. 
   Licensed under the MIT License. See the LICENSE file in the RemoteXY library
   root (https://github.com/RemoteXY/RemoteXY-Arduino-library) for full license 
   details.             
*/

//////////////////////////////////////////////
//        RemoteXY include library          //
//////////////////////////////////////////////

// you can enable debug logging to Serial at 115200
//#define REMOTEXY__DEBUGLOG

// RemoteXY select connection mode and include library
#define REMOTEXY_MODE__WIFI_POINT

#include <WiFi.h>

// RemoteXY connection settings
#define REMOTEXY_WIFI_SSID "RemoteXY"
#define REMOTEXY_WIFI_PASSWORD "12345678"
#define REMOTEXY_SERVER_PORT 6377
#define REMOTEXY_ACCESS_PASSWORD "12345678"


#include <RemoteXY.h>

// RemoteXY GUI configuration
#pragma pack(push, 1)
uint8_t RemoteXY_CONF[] =  // 282 bytes
  { 255, 4, 0, 3, 0, 19, 1, 19, 0, 0, 0, 66, 114, 97, 110, 101, 87, 97, 105, 118,
    0, 195, 1, 106, 200, 1, 1, 11, 0, 65, 44, 4, 18, 18, 112, 129, 25, 27, 57, 12,
    64, 6, 66, 114, 97, 110, 101, 87, 97, 105, 118, 0, 129, 34, 60, 39, 12, 64, 6, 80,
    97, 116, 116, 101, 114, 110, 0, 129, 40, 96, 29, 12, 64, 6, 87, 97, 118, 101, 0, 12,
    29, 74, 54, 11, 195, 30, 26, 49, 32, 76, 69, 68, 0, 53, 32, 76, 69, 68, 115, 0,
    57, 32, 76, 69, 68, 115, 0, 49, 51, 32, 76, 69, 68, 115, 0, 50, 53, 32, 76, 69,
    68, 115, 0, 12, 18, 109, 76, 10, 196, 30, 26, 68, 101, 108, 116, 97, 32, 49, 45, 53,
    32, 72, 122, 0, 84, 104, 101, 116, 97, 32, 52, 45, 56, 32, 72, 122, 0, 65, 108, 112,
    104, 97, 32, 56, 45, 49, 50, 32, 72, 122, 0, 66, 101, 116, 97, 32, 49, 51, 45, 50,
    53, 32, 72, 122, 0, 71, 97, 109, 109, 97, 32, 50, 53, 45, 51, 53, 32, 72, 122, 0,
    65, 109, 98, 105, 101, 110, 116, 0, 10, 42, 169, 24, 24, 48, 1, 12, 31, 79, 70, 70,
    0, 31, 79, 78, 0, 129, 38, 156, 34, 12, 64, 6, 80, 111, 119, 101, 114, 0, 129, 25,
    40, 60, 8, 0, 6, 77, 111, 111, 100, 32, 83, 116, 105, 109, 117, 108, 97, 116, 111, 114,
    0, 4, 17, 138, 75, 12, 160, 6, 26, 129, 36, 123, 34, 12, 64, 6, 83, 112, 101, 101,
    100, 0 };

// this structure defines all the variables and events of your control interface
struct {

  // input variables
  uint8_t patternSelector;  // from 0 to 5
  uint8_t waveSelector;     // from 0 to 6
  uint8_t btnPower;         // =1 if state is ON, else =0, from 0 to 1
  int8_t speed;             // from -100 to 100

  // output variables
  uint8_t led_01_r;  // =0..255 LED Red brightness, from 0 to 255
  uint8_t led_01_g;  // =0..255 LED Green brightness, from 0 to 255
  uint8_t led_01_b;  // =0..255 LED Green brightness, from 0 to 255

  // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0

} RemoteXY;
#pragma pack(pop)

/////////////////////////////////////////////
//           END RemoteXY include          //
/////////////////////////////////////////////



/////////////////////////////////////////////
//              START MY CODE              //
/////////////////////////////////////////////
/*
  This code is free for personal use, if you want to modify the code please credit me it.
  I assert my copyright Ralph Beardmore AKA, TekMaker (UK). 19/10/2025
*/
#include <Adafruit_NeoPixel.h>
//#define LED_BUILTIN 2  // just for indication on board
#define PIN_WS2812B 8  // The ESP32 pin GPIO16 connected to WS2812B
#define NUM_PIXELS 25  // The number of LEDs (pixels) on WS2812B LED strip
#define numWaves 6
String waveName[numWaves] = { "Delta 1-3", "Theta 4-8", "Alpha 8-12", "Beta 13-25", "Gamma 25-35", "Ambient" };

// these are the frequencies for each mode
int mode[numWaves] = { 2, 5, 10, 21, 40, 1000 };  // the frequencies for the wave patterns

int colour[numWaves][3] = {
  { 255, 127, 0 },   // yellow/orange   Gamma - High thought, focus level and awareness
  { 32, 64, 255 },   // blue             Beta - Awake, normal, alert, consciousness
  { 255, 16, 255 },  // purple           Alpha = Relaxed, lucid, calm, not thinking
  { 255, 16, 32 },   // red              Theta - Deep relaxation, meditation, mental imagery
  { 16, 233, 32 },   // green            Delta - Deep, dreamless sleep
  { 255, 206, 161 }  // 4500K            Ambient (slightly cool neutral)
};
/* Additional ambient colors
  // { 255, 180, 107 },  // 3000K (warm white, halogen)
  // { 255, 188, 132 },  // 3500K (warm neutral)
  // { 255, 197, 143 },  // 4000K (neutral white)
  // { 255, 206, 161 },  // 4500K (slightly cool neutral)
  // { 255, 214, 179 },  // 5000K (daylight white)
  // { 255, 219, 193 },  // 5500K (noon daylight)
  // { 255, 225, 209 },  // 6000K (cool daylight)
  // { 255, 229, 229 }   // 6500K (standard daylight / D65)
  */

/*
level 1-1 led
0 0 0 0 0 
0 0 0 0 0 
0 0 1 0 0 
0 0 0 0 0 
0 0 0 0 0 

level 2 -5 leds 
0 0 0 0 0 
0 1 0 1 0 
0 0 1 0 0 
0 1 0 1 0 
0 0 0 0 0 

level 3-9 leds
0 0 1 0 0
0 1 0 1 0 
1 0 1 0 1
0 1 0 1 0 
0 0 1 0 0

level 4-13 leds
1 0 1 0 1
0 1 0 1 0 
1 0 1 0 1
0 1 0 1 0 
1 0 1 0 1

level 5-25 leds
1 1 1 1 1 
1 1 1 1 1 
1 1 1 1 1
1 1 1 1 1 
1 1 1 1 1
*/

/* Pixel patterns for different brightnesses */
#define numPatterns 5
int patterns[numPatterns][25] = {
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0 },
  { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 },
  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
};

// global variables for modes
uint8_t pattern = 0;      // 0 indexed
uint8_t wave = 0;         // 0 indexed
uint8_t steps = 10;       // number of brightness steps
unsigned long startTime;  // time start pressed
unsigned long curTime;    // current milliseconds

// define ws2812 object
Adafruit_NeoPixel ws2812b(NUM_PIXELS, PIN_WS2812B, NEO_GRB + NEO_KHZ800);

void setup() {
  RemoteXY_Init();
  Serial.begin(31250);
  startTime = millis();  // get initial timer

  // built in led is [0]
  ws2812b.begin();  // initialize WS2812B strip object (REQUIRED)
  ws2812b.clear();  // set all pixel colors to 'off'. It only takes effect if pixels.show() is called
  ws2812b.show();
}

// main program loop
void loop() {
  RemoteXY_Handler();
  pattern = RemoteXY.patternSelector;
  wave = RemoteXY.waveSelector;

  float freqHz = mode[wave];
  float speed = RemoteXY.speed;

  if (speed >= 100) speed = 100;
  if (speed <= -100) speed = -100;

  freqHz = freqHz * (1.0 + (speed / 100.0) * 0.25);  // speed ranges from -100 to 100
  float dly = (1000 / freqHz);                       // convert frequencyHz to period and adjust;

  Serial.print(freqHz);
  Serial.print(" ");
  Serial.print(mode[wave]);
  Serial.print(" ");
  Serial.println(speed);

  if (RemoteXY.connect_flag == 0) {  // kill display until connected
    flashLEDs(0, 0, 0, dly, pattern, steps);
    startTime = millis();
    curTime = startTime;
  } else {
    if (dly > 2 && RemoteXY.btnPower == 1) {
      curTime = millis();  // only run timer when running
      flashLEDs(colour[wave][0], colour[wave][1], colour[wave][2], dly, pattern, steps);
    } else {
      startTime = millis();
      curTime = startTime;
      showAmbient(colour[wave][0], colour[wave][1], colour[wave][2], pattern);
    }
  }
}

void showAmbient(int r, int g, int b, int pattern) {
  for (int pixel = 0; pixel < NUM_PIXELS; pixel++) {
    if (patterns[pattern][pixel] == 1 && RemoteXY.btnPower == 1) {
      ws2812b.setPixelColor(pixel, ws2812b.Color(r, g, b));
    } else {
      ws2812b.clear();
    }
  }
  ws2812b.show();
}

void flashLEDs(float r, float g, float b, int dly, int index, float stepsCount) {

  // to make the effect less annoying we'll use to separate loops to increment and decrement
  // the brightness gradually in stepsCount steps

  for (int step = 0; step <= stepsCount; step++) {  // step loop increasing brightness
    int d = dly / (2 * stepsCount);
    int rval = (r * step) / stepsCount;
    int gval = (g * step) / stepsCount;
    int bval = (b * step) / stepsCount;

    for (int pixel = 0; pixel < NUM_PIXELS; pixel++) {  // pixel loop
      if (patterns[index][pixel] == 1 && RemoteXY.btnPower == 1) {
        RemoteXY.led_01_r = rval;  // program the RGB led on RemoteXY
        RemoteXY.led_01_g = gval;
        RemoteXY.led_01_b = bval;
        ws2812b.setPixelColor(pixel, ws2812b.Color(rval, gval, bval));
      } else {
        if (dly > 2) {  // then show a solid ambient color
          ws2812b.setPixelColor(pixel, ws2812b.Color(0, 0, 0));
        }
      }
    }
    ws2812b.show();
    RemoteXY_delay(d);
  }

  for (int step = stepsCount; step >= 0; step--) {  // step loop decreasing brightness
    int d = dly / (2 * stepsCount);
    int rval = r * (step / stepsCount);
    int gval = g * (step / stepsCount);
    int bval = b * (step / stepsCount);

    for (int pixel = 0; pixel < NUM_PIXELS; pixel++) {  // pixel loop
      if (patterns[index][pixel] == 1 && RemoteXY.btnPower == 1) {
        ws2812b.setPixelColor(pixel, ws2812b.Color(rval, gval, bval));
      } else {
        if (dly > 20) {
          ws2812b.setPixelColor(pixel, ws2812b.Color(0, 0, 0));
        }
      }
    }
    ws2812b.show();
    RemoteXY_delay(d);
  }
}
